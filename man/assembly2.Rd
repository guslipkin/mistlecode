% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/assembly2.R
\name{create_assembly2}
\alias{create_assembly2}
\title{Create an AoC Assembly Computer}
\usage{
create_assembly2(
  registers,
  functions,
  increment = 1,
  regex = "[\\\\w\\\\d\\\\-]+"
)
}
\arguments{
\item{registers}{A named list of registers.}

\item{functions}{A named list of functions. Registers can be referred to with
\code{self[[register_name]]}. Functions usually take a register and value as
arguments, but do not always. Registers can be referenced by name with
\code{self$register_name}, or by variable with \code{self[[var]]}.}

\item{increment}{(Default: \code{1}) The number of places to increment by default.
Incrementing is performed automatically so if a particular instruction says
to increment by more than one, then include that operation in the function,
but subtract one to account for the default incrementation.}

\item{regex}{(Default: \code{"[\\\\w\\\\d\\\\-]+"}) The pattern to use for
\link[stringr:str_match]{stringr::str_match_all}. Capture groups should not be used, instead the
\code{|} (or) operator should be used. For example, if you want to parse an
arbitrary instruction then a number, you would use \verb{[A-z]+|[0-9]+}.}
}
\value{
A new \code{assembly} R6 object with \code{registers} and \code{functions} as the
fields and methods, respectively. Along with the functions detailed in the
details section.
}
\description{
Create an AoC Assembly Computer
}
\details{
\code{try_numeric(x)}
:  Takes input and tries to cast it as numeric. If that fails, it returns the
original object.

\code{val_or_index(x)}
:  If \code{x} is numeric, return \code{x}, otherwise return \code{self[[x]]}.

\code{jump(x, y)}
:  A shortcut for a common jump scheme. Can be called with
\verb{"jump_fun" = \\(x, y) \{ self$jump(x, y) \}}.

\code{call(f, x, y)}
:  Calls one of \code{functions} using \code{x} and \code{y} as arguments.
There are two ways the function can be used:
\itemize{
\item \code{f} is not length one and \code{x} and \code{y} are null, then \code{f[1](f[2], f[3])}
\item \code{f} is length one, and \code{x} and \code{y} are not null, then \code{f(x, y)}
}

\code{run(x, target, until, pattern)}
:  Tries to run the instructions provided by \code{x}. If \code{x} is a character
vector, it will try to split the instructions into a segments for
\code{call(f, x, y)}.
\itemize{
\item \code{x}: A character vector of instructions as \code{c("f x y")} or a list of
character vectors in the format \code{list(c("f", "x", "y"))}
\item \code{target}: (Default: \code{NULL}) The \code{register} to print as the final result.
If \code{NULL}, \code{self} will be printed.
\item \code{pattern}: See the \code{regex} argument for more details.
}

\code{.inc(increment)}
:  A private function used to increment \code{self$index} by \code{increment}.
}
\examples{
\dontrun{
registers <- list("a" = 1, "b" = 2)
functions <- list(
  "sum" = \(x, y) { self[[x]] <- sum(self[[x]], y) },
  "prod" = get_premade("multiply")
)
a <- create_assembly2(registers, get_premade(c("add", "prod" = "multiply")))
a$run(c("add a 4", "prod b 4"), target = 'a')
}

}
